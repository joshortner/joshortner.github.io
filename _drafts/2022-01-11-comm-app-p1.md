---
layout: post
title:  Communication Application Devlog 1
permalink: /comm-app-dev-part-one
type: blog
---

# 1. Introduction

This is the first blog in a series where I'll document my progress developing a private, web-based messaging application. There are two primary goals for this project:

1. Gain a deeper understanding of web technologies. Specifically:
- Golang
- ReactJS
- Websockets and HTTP
- The networking stack in general

2. Develop an open-source, decentralized communication application.

The first goal is the focus for now. The second goal is the larger vision for the project. I always like to have an ambitious goal for any project I start to act as a guiding light.

I'll discuss specific features for the minimum viable product in the next section. But the general idea of the application is that users will be able to host their own servers, and clients will be able connect to a server, create an account and communicate with other users registered on the server. It's similar to how some online video games work: Minecraft and Valheim are good examples. 

These posts are going to detail as much of the implementation as possible. For now I'll touch on just about every line of code I add, but that may change as the application grows in complexity. 

# 2. The MVP

<img src="{{site.url}}/public/media/comm/p1/architecture.jpeg" alt="drawing" height="250" style="margin: 0 auto"/>

The unique aspect of this application is that the servers are user-owned. That means anyone can download the code and run a server on their own machine. The client is essentially a simple interface to connect to and interact with a server.

Server MVP features:
1. Create an account
2. Login to an existing account
3. Manage conversations with other users
4. Send and recieve messages in real time
5. Interface to manage user privileges

Client MVP:
1. Interface to the server features 1-4

Each post will describe the implementation details of a small set of features. This post will touch on:
1. Server initialization and startup
2. Logging
3. Command Line Interface
4. The first HTTP endpoint: User Registration

A couple things I'd like to note before moving forward. There are some important things that I'm going to intentionally ignore until I have a decent server MVP. Those are:
1. A nice looking client. Any client code I write for now will be for testing the functionality of the server. It'll be vanilla JavaScript and not pretty.
2. Concurrency. Golang has really nice features for writing concurrent code, and concurrency is absolutely necessary for an applicaiton like this to scale. While I'm keeping this in mind, I probably won't implement this until I have a better idea of how all the pieces are going to fit together. Once I have an MVP I can run tests and experiments to find the best use of concurrency.
3. I'm developing and testing everything locally. Opening up a local network to be accessible from the internet is a whole process with it's own set of complications. This is also, something I'm pushing off until the completion of the MVP. 

Also, in order to keep the posts focused I won't show error handling or the delcaration of constants. Constants are denoted in the code by all caps, snake case variables.

# 3. The Server

We'll start with a dead simple empty struct to represent the Server. It will hold all of the necessary systems/objects required for the server to run. 

{% highlight golang %}

// File: server/server.go

type Server struct {

}

func NewServer() Server {
    return Server{}
}

{% endhighlight %}

And the entry point looks like this:

{% highlight golang %}

// File: main.go

func main() {
    cxt := NewServer()
}

{% endhighlight %}

This code obviously doesn't do anything yet, but each section will add new data and functionality so I'm including it for the sake of clarity.

# 4. Server initialization and Startup

There are two potential launch states for the server.

1. The first launch - referred to as initialization
2. Any subsequent launch - referred to as a startup

## 4.1 Initialization

The first extension of the NewServer function should be straight forward: check if the given directory exists, if it doesn't then run initialization code. 

{% highlight golang %}

// File: server/server.go

func NewServer(serverDir string) Server {
    exists, err := utils.PathExists(serverDir)

    if !exists {
        initializeServer()
    }
}

// File: main.go

...
cxt := NewServer("./srv")
...

{% endhighlight %}

I've implemented the PathExists function in a package called utils. It wraps up a couple functions from the os package[^fn1]:

{% highlight golang %}

// File: utils/file.go

func PathExists(path string) (bool, error) {
    _, err := os.Stat(path)
    if err == nil { return true, nil }
    if os.IsNotExist(err) { return false, nil }
    return false, err
}

{% endhighlight %}

If the server hasn't been initialized then we need to generate some directories and files. For now that's only the main server directory and a log directory. This happens in the initializeServer function. For convenience I'm also creating a struct to hold all of the server directories and file paths.

{% highlight golang %}

// File: server/server.go

type ServerDiskContext struct {
    BaseDir string
    LogDir string
}

func NewServer(serverDir string) Server {
    ...
    diskCxt := ServerDiskContext{
        BaseDir: serverDir, 
        LogDir: filepath.Join(serverDir, LOG_DIRECTORY),
    }

    if !exists {
        initializeServer(diskCxt)
    }
    ..
}

func initializeServer(diskContext ServerDiskContext) {
	err := os.Mkdir(diskContext.BaseDir, 0755)

	err = os.Mkdir(diskContext.LogDir, 0755)
}

{% endhighlight %}

Running this code will produce a directory like this:

```bash
C:/path/to/build
│   <server>.exe
│
└───srv
    └───log
```

## 4.2 Startup

Now we need a function to actually load or generate required resources. Again, there isn't much happening here, but it's structure that can be extended.

{% highlight golang %}

// File: server/server.go

type Server struct {
    DiskContext ServerDiskContext
}

func NewServer(serverDir string) *Server {
    ...

    server := startupServer(diskCxt)
    return server
}

func startupServer(diskContext ServerDiskContext) *Server {
    return &Server{
        DiskContext: diskContext,
    }
}

{% endhighlight %}

# 5. Logging

There's a nice logging package available for Go that I'll use for now[^fn2]. It has various print functions built in and the ability to set a file to pipe the output to. For now, this is all I need. I'll add a function to generate a new log file and the first log call at the end of the NewServer function.

{% highlight golang %}

func NewServer(serverDir string) *Server {
    ...
    log.Println("Server startup completed!")
    return server
}

func startupServer(diskContext ServerDiskContext) *Server {
    server := Server{
        DiskContext: diskContext,
    }

    server.GenerateNewLogFile()
    return &server
}

{% endhighlight %}

Now, to implement GenerateNewLogFile. To generate a log file path I'll use Go's time package[^fn3] to get a time stamp and then convert that to a string and append it to the log directory. I may come up with a better convention for naming log files, but this works for now.

{% highlight golang %}

func (s *Server) GenerateNewLogFile() {
	newLogPath := filepath.Join(s.DiskContext.LogDir, 
                                    "log_" + time.Now().Format("2006-01-02_15:04:05"))
}

{% endhighlight %}

Then I create the file and and set the output of the log package. The flags are settings to tell the log package how to format the messages it generates.

{% highlight golang %}

func (s *Server) GenerateNewLogFile() {
    ...
    logFile, err := os.OpenFile(newLogPath, 
                                os.O_RDWR | os.O_CREATE | os.O_APPEND, 
                                0666) 

    log.SetFlags(log.Lshortfile | log.LstdFlags)
    log.SetOutput(logFile)
}

{% endhighlight %}

After building and running this the server directory looks like this:

```bash
C:/path/to/build
│   <server>.exe
│
└───srv
    └───log
        │   log_2022-01-11_18:58:19     
```

And the contents of the log file are:

```bash
2022/01/11 18:58:19 server.go:37: Server startup completed!
```

# 6. Command Line Interface

A command line interface will give the user the ability to interact with the server. It'll also be nice for debugging to have some hooks to access the server internals while it's running. 

The CLI will run in it's own Go thread, read input from the terminal, check if the input matches an internal command, and then run the function associated with that command. None of the commands are hard coded into the CLI itself, instead the api will allow users to add new commands.

I'll make a new package call cli, and use Go's bufio package to read input from the terminal [^fn4]:

{% highlight golang %}

// FILE: cli/cli.go

type CLI struct {	
    Reader *bufio.Reader
}

func NewCLI() CLI {
    return CLI{
        Reader: bufio.NewReader(os.Stdin),
    }
}

func (cli *CLI) Run() {
	
    fmt.Println("|------------------------------------|")
    fmt.Println("|----- SERVER CLI Version 0.0.0 -----|")
    fmt.Println("|------------------------------------|")

    for {
        fmt.Print("server> ")

        cmd, err := cli.Reader.ReadString('\n')

        if err != nil {
            fmt.Println("Error! -", err)
        }

        cmd = strings.TrimSpace(cmd)

        fmt.Println(cmd)
    }

}

// File: main.go

func main() {
    ...
    cmdli := cli.NewCLI()
    cmdli.Run()
    ...
}

{% endhighlight %}

The above code produces the following output:

<img src="{{site.url}}/public/media/comm/p1/cli.png" alt="drawing" height="200" style="margin: 0 auto"/>

Now I need a way to add commands and callbacks. To implement this I'll just a hash map to map the command string to a callback function. I'll make a new struct to hold command information, add a map to the CLI struct and extend the api to add commands.

{% highlight golang %}

// FILE: cli/cli.go

type CLI struct {	
    ...
    CommandMap map[string]CommandInfo
}

type CommandInfo struct {
    Name string 
    Info string
    Callback func()
}

func NewCLI() CLI {
    return CLI{
        Reader: bufio.NewReader(os.Stdin),
        CommandMap: make(map[string]CommandInfo),
    }
}

func (cli *CLI) RegisterCommand(cmdInfo CommandInfo) {
    defaultCommands := []string{ HELP_COMMAND }

    for _, defCmd := range defaultCommands {
        if defCmd == cmdInfo.Name {
            log.Printf("Can't register command '%v', it is a built-in command", cmdInfo.Name)
            return
        }
    }
    
    _, ok := cli.CommandMap[cmdInfo.Name]

    if ok {
        log.Println("Command already registered", cmdInfo.Name)
    } else {
        log.Println("Command registered:", cmdInfo.Name)
        cli.CommandMap[cmdInfo.Name] = cmdInfo
    }
}

{% endhighlight %}

I'll also edit the CLI's Run function to handle a command received from input.

{% highlight golang %}

// FILE: cli/cli.go

func (cli *CLI) Run() {
    ...
    for {
        ...
        cli.handleCommand(cmd)
    }
}

func (cli *CLI) handleCommand(cmd string) {
    switch cmd {
        case HELP_COMMAND:
            if len(cli.CommandMap) == 0 {
                fmt.Println("No commands available")	
            } else {
                fmt.Println("Available Commands:")
                for key, cmdInfo := range cli.CommandMap {
                    fmt.Printf("\t- %s: %s\n", key, cmdInfo.Info)
                }
            }

        default:
            cmdInfo, ok := cli.CommandMap[cmd]
            if ok {
                cmdInfo.Callback()
            } else {
                fmt.Println("Unknown Command:", cmd)
            }
    }
}



{% endhighlight %}

# . The first HTTP endpoint: User Registration

# . Sources
[^fn1]: [go-os](https://pkg.go.dev/os)
[^fn2]: [go-log](https://pkg.go.dev/log)
[^fn3]: [go-time](https://pkg.go.dev/time)
[^fn4]: [go-time](https://pkg.go.dev/bufio)

