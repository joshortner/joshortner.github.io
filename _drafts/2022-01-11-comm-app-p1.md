---
layout: post
title:  Communication Application Devlog 1
permalink: /comm-app-dev-part-one
type: blog
---

# 1. Introduction

This is the first blog in a series where I'll document my progress developing a private, web-based messaging application. There are two primary goals for this project:

1. Gain a deeper understanding of web technologies. Specifically:
- Golang
- ReactJS
- Websockets and HTTP
- The networking stack in general

2. Develop an open-source, decentralized communication application.

The first goal is the most pressing. The second is the larger vision for the project. I always like to have an ambitious goal for any project I start to act as a guiding light when I begin to get into the weeds.

# 2. The MVP

<img src="{{site.url}}/public/media/comm/p1/architecture.jpeg" alt="drawing" height="250" style="margin: 0 auto"/>

The most important aspect of this application is that the servers are user-owned. That means anyone can download the code and run a server on their own machine. The clients will be provided with the functionality to connect to a server of choice, and server managers will be able to manage the authorization of users attempting to access their servers.

The MVP features I'm going to include for the client are:
1. Create an account
2. Login to an existing account
3. Manage conversations with other users
4. Send and recieve messages in real time

In addition to enabling each of the above features, the MVP for the server should also provide some kind of interface for managing user privileges.

In these write-ups I will describe the implementation details of a small set of features that I've implemented. In this post I'll discuss:
1. Server initialization and startup
2. Logging
3. Command Line Interface and User Authorization File
4. Database
5. The first HTTP endpoint: User Registration

A couple things I'd like to note before moving forward. There are some important things that I'm going to intentionally ignore until I have a decent server MVP. Those are:
1. A nice looking client. Any client code I write for now will be for testing the functionality of the server. It'll be vanilla JavaScript and not pretty.
2. Concurrency. Golang has really nice features for writing concurrent code, and concurrency is absolutely necessary for an applicaiton like this to scale. While I'm keeping this in mind, I probably won't implement this until I have a better idea of how all the pieces are going to fit together. Once I have an MVP I can run tests and experiments to find the best use of concurrency.
3. I'm developing and testing everything locally. Opening up a local network to be accessible from the internet is a whole process with it's own set of complications. This is also, something I'm pushing off until the completion of the MVP. 
4. TO DO : For the sake of brevity I won't show error handling or the delcaration of constants. Constants are denoted in the code by all caps, snake case variables.

# 3. The Server

We'll start with a dead simple empty struct to represent the Server. It will hold all of the necessary systems/objects required for the server to run. 

{% highlight golang %}

// File: server/server.go

type Server struct {

}

func NewServer() Server {
    return Server{}
}

{% endhighlight %}

And the entry point looks like this:

{% highlight golang %}

// File: main.go

func main() {
    cxt := NewServer()
}

{% endhighlight %}

This code obviously doesn't do anything, but each section will add new data and functionality to the Server Struct so I'm including it for the sake of clarity.

# 4. Server initialization and Startup

There are two potential startup states for the server.

1. The first launch - referred to as initialization
2. Any subsequent launch - referred to as a startup

## 4.1 Initialization

Here's the first extension of the NewServer function:

{% highlight golang %}

// File: server/server.go

func NewServer(serverDir string) Server {
    exists, err := utils.PathExists(serverDir)

    if !exists {
        initializeServer()
    }
}

// File: main.go

...
cxt := NewServer("./srv")
...

{% endhighlight %}

I've implemented the PathExists function in a package called utils. It wraps up a couple functions from the os package[^fn1]:

{% highlight golang %}

// File: utils/file.go

func PathExists(path string) (bool, error) {
    _, err := os.Stat(path)
    if err == nil { return true, nil }
    if os.IsNotExist(err) { return false, nil }
    return false, err
}

{% endhighlight %}

If the server directory doesn't exist yet then we need to generate some directories and files. For now that includes the main server directory and a directory for log files. This happens in the initializeServer function. For convenience I'm also creating a struct to hold all of the server directories and file paths.

{% highlight golang %}

// File: server/server.go

type ServerDiskContext struct {
    BaseDir string
    LogDir string
}

func NewServer(serverDir string) Server {
    ...
    diskCxt := ServerDiskContext{
        BaseDir: serverDir, 
        LogDir: filepath.Join(serverDir, LOG_DIRECTORY),
    }

    if !exists {
        initializeServer(diskCxt)
    }
    ..
}

func initializeServer(diskContext ServerDiskContext) {
	err := os.Mkdir(diskContext.BaseDir, 0755)

	err = os.Mkdir(diskContext.LogDir, 0755)
}

{% endhighlight %}

The server directory so far looks like this:

```bash
C:/path/to/build
│   <server>.exe
│
└───srv
    └───log
```

## 4.2 Startup

Now we need to setup the server and actually load/generate resources. Again, there isn't much happening here, but we have a server, a directory and some code structure to add more functionality.

{% highlight golang %}

// File: server/server.go

type Server struct {
    DiskContext ServerDiskContext
}

func NewServer(serverDir string) *Server {
    ...

    server := startupServer(diskCxt)
    return server
}

func startupServer(diskContext ServerDiskContext) *Server {
    return &Server{
        DiskContext: diskContext,
    }
}

{% endhighlight %}

# 5. Logging

There's a nice logging package available for Go that I'll use for now[^fn2]. It has various print functions built in and the ability to set a file to pipe the output to. For now, this is all I need. I'll add a log call to the end of the NewServer function and rearrange the startupServer function.

{% highlight golang %}

func NewServer(serverDir string) *Server {
    ...
    log.Println("Server startup completed!")
    return server
}

func startupServer(diskContext ServerDiskContext) *Server {
    server := Server{
        DiskContext: diskContext,
    }

    server.GenerateNewLogFile()
    return &server
}

{% endhighlight %}

We have a new function to implement: GenerateNewLogFile. Again, I'm going to stick with simple solutions for now. To generate a log file path I'll use Go's time package[^fn3] to get a time stamp and then convert that to a string and append it to the log directory. Don't be confused by the date and time of the string passed to the Format function. It uses that string as a format reference, the actual time is generated by the call to Now.

{% highlight golang %}

func (s *Server) GenerateNewLogFile() {
	newLogPath := filepath.Join(s.DiskContext.LogDir, time.Now().Format("2006-01-02_15:04:05"))
}

{% endhighlight %}

Then I create the file and and set the output of the log package.

{% highlight golang %}

func (s *Server) GenerateNewLogFile() {
    ...
    logFile, err := os.OpenFile(newLogPath, os.O_RDWR | os.O_CREATE | os.O_APPEND, 0666) 

    log.SetFlags(log.Lshortfile | log.LstdFlags)
    log.SetOutput(logFile)
}

{% endhighlight %}

After building and running this the server directory looks like this:

```bash
C:/path/to/build
│   <server>.exe
│
└───srv
    └───log
        │   2022-01-11_18:58:19     
```

And the contents of the log file are:

```bash
2022/01/11 18:58:19 server.go:37: Server startup completed!
```

# . Command Line Interface and User Authorization File
# . Database
# . The first HTTP endpoint: User Registration

# . Sources
[^fn1]: [go-os](https://pkg.go.dev/os)
[^fn2]: [go-log](https://pkg.go.dev/log)
[^fn3]: [go-time](https://pkg.go.dev/time)

